<!DOCTYPE html>


<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AquaSense - Water Quality Monitoring Dashboard</title>
    <link rel="icon" type="image/png" href="logo_aquasense.png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
        }
        
        .dashboard {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 280px;
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        .sidebar h1 {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
            color: #3498db;
        }
        
        .user-info {
            background-color: #34495e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .user-info .username {
            font-weight: bold;
            color: #3498db;
            margin-bottom: 5px;
        }
        
        .user-info .role {
            font-size: 12px;
            color: #bdc3c7;
        }
        
        .nav-item {
            padding: 15px 20px;
            margin-bottom: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid transparent;
            display: flex;
            align-items: center;
        }
        
        .nav-item:hover {
            background-color: #34495e;
            border-left-color: #3498db;
        }
        
        .nav-item.active {
            background-color: #3498db;
            border-left-color: #2980b9;
        }
        
        .nav-item i {
            margin-right: 10px;
            font-size: 16px;
        }
        

        
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            height: 100vh;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .filters {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .filter-select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background-color: white;
        }
        
        .cage-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }
        
        .cage-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #3498db;
        }
        
        .cage-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        .chart-container {
            height: 250px;
            margin-bottom: 15px;
        }
        
        .download-btn {
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }
        
        .download-btn:hover {
            background-color: #219a52;
        }
        
        .download-btn-prominent {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .download-btn-prominent:hover {
            background: linear-gradient(135deg, #2980b9, #1f618d);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(52, 152, 219, 0.4);
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-online {
            background-color: #27ae60;
        }
        
        .status-offline {
            background-color: #e74c3c;
        }
        
        .aerator-on {
            background-color: #27ae60;
        }
        
        .aerator-off {
            background-color: #e74c3c;
        }
        
        .overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .overview-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            text-align: center;
            border-left: 4px solid #3498db;
            position: relative;
        }
        
        .overview-card.do-card {
            border-left-color: #27ae60;
        }
        
        .overview-card.voltage-card {
            border-left-color: #3498db;
        }
        
        .overview-card.battery-card {
            border-left-color: #f39c12;
        }
        
        .overview-value {
            font-size: 36px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .overview-label {
            color: #666;
            font-size: 16px;
            font-weight: 500;
        }
        
        .overview-trend {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 14px;
            color: #27ae60;
        }
        
        .do-chart-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        .do-chart-container h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .chart-wrapper {
            height: calc(100vh - 250px);
            min-height: 400px;
            position: relative;
        }
        
        /* Login Modal Styles */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .login-box {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 400px;
            text-align: center;
        }
        
        .login-box h2 {
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        .login-box input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #e1e1e1;
            border-radius: 6px;
            font-size: 16px;
        }
        
        .login-box input:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .login-box button {
            width: 100%;
            padding: 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 15px;
        }
        
        .login-box button:hover {
            background: #2980b9;
        }
        
        .login-box p {
            color: #666;
            font-size: 14px;
        }
        
        .settings-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background-color 0.3s;
            margin-top: 8px;
            width: 100%;
        }
        
        .settings-btn:hover {
            background-color: #2980b9;
        }
        
        .time-range-selector select {
            background-color: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .time-range-selector select:hover {
            border-color: #3498db;
            background-color: #ffffff;
        }
        
        .time-range-selector select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .logout-btn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
            transition: background-color 0.3s;
        }
        
        .logout-btn:hover {
            background-color: #c0392b;
        }
        
        /* Password change functionality removed */
        .modal {
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            position: relative;
            background-color: white;
            margin: 10% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 450px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-header {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }
        
        .close {
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        
        .close:hover {
            opacity: 1;
        }
        
        .modal-body {
            padding: 25px;
        }
        
        .modal-body .form-group {
            margin-bottom: 20px;
        }
        
        .modal-body label {
            display: block;
            margin-bottom: 8px;
            color: #2c3e50;
            font-weight: 500;
            font-size: 14px;
        }
        
        .modal-body input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        
        .modal-body input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .form-actions {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 25px;
        }
        
        .btn-cancel {
            background-color: #95a5a6;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        
        .btn-cancel:hover {
            background-color: #7f8c8d;
        }
        
        .btn-save {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }
        
        .btn-save:hover {
            background: linear-gradient(135deg, #229954, #27ae60);
            transform: translateY(-1px);
        }
        
        .message {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* Mobile Menu Toggle */
        .mobile-menu-toggle {
            display: none;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            background: #2c3e50;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .mobile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .dashboard {
                flex-direction: column;
            }
            
            .sidebar {
                position: fixed;
                top: 0;
                left: -100%;
                width: 280px;
                height: 100vh;
                z-index: 1000;
                transition: left 0.3s ease;
                box-shadow: 2px 0 20px rgba(0,0,0,0.3);
            }
            
            .sidebar.mobile-open {
                left: 0;
            }
            
            .mobile-menu-toggle {
                display: block;
            }
            
            .mobile-overlay.active {
                display: block;
            }
            
            .main-content {
                padding: 70px 15px 15px 15px;
                width: 100%;
            }
            
            .header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .header h2 {
                font-size: 24px;
                text-align: center;
            }
            
            .filters {
                justify-content: center;
            }
            
            .overview-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 15px;
            }
            
            .overview-card {
                padding: 20px 15px;
            }
            
            .overview-value {
                font-size: 28px;
            }
            
            .do-chart-container {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            .do-chart-container h3 {
                font-size: 18px;
                text-align: center;
            }
            
            .chart-wrapper {
                height: 300px;
            }
            
            .cage-card {
                padding: 15px;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 8px;
            }
            
            .stat-item {
                padding: 8px;
            }
            
            .stat-value {
                font-size: 16px;
            }
            
            .stat-label {
                font-size: 11px;
            }
            
            .chart-container {
                height: 200px;
            }
            
            .download-btn {
                width: 100%;
                margin-bottom: 10px;
            }
            
            .nav-item {
                padding: 18px 20px;
                font-size: 16px;
                justify-content: center;
            }
            
            .user-info {
                text-align: center;
                padding: 20px 15px;
            }
            
            .logout-btn {
                padding: 15px 20px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .main-content {
                padding: 60px 10px 10px 10px;
            }
            
            .overview-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .overview-card {
                padding: 15px 10px;
            }
            
            .overview-value {
                font-size: 24px;
            }
            
            .overview-label {
                font-size: 14px;
            }
            
            .do-chart-container {
                padding: 10px;
            }
            
            .do-chart-container h3 {
                font-size: 16px;
            }
            
            .chart-wrapper {
                height: 250px;
            }
            
            .cage-card {
                padding: 12px;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
            
            .stat-item {
                padding: 6px;
                font-size: 12px;
            }
            
            .stat-value {
                font-size: 14px;
            }
            
            .filter-select {
                width: 100%;
                padding: 10px;
                font-size: 14px;
            }
            
            .sidebar {
                width: 100%;
                left: -100%;
            }
            
            .nav-item {
                padding: 20px;
                font-size: 18px;
                border-left: none;
                border-bottom: 1px solid #34495e;
            }
            
            .nav-item:hover,
            .nav-item.active {
                border-left: none;
                border-bottom: 3px solid #3498db;
            }
        }
    </style>
</head>
<body>
    <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">â˜°</button>
    <div class="mobile-overlay" onclick="closeMobileMenu()"></div>
    
    <div class="dashboard">
        <div class="sidebar" id="sidebar">
            <h1>
                <img src="logo_aquasense.png" alt="AquaSense Logo" style="width: 40px; height: 40px; margin-right: 10px; vertical-align: middle;">
                AquaSense
            </h1>
            
            <div class="user-info">
                <div class="username" id="user-name">AquaSense Admin</div>
                <div class="role">System Administrator</div>
            </div>
            
            <div class="nav-item active" data-view="dashboard">
                ðŸ“Š Dashboard
            </div>
            <div class="nav-item cage-nav" data-view="cage1">
                Cage 1
            </div>
            <div class="nav-item cage-nav" data-view="cage2">
                Cage 2
            </div>
            <div class="nav-item cage-nav" data-view="cage3">
                Cage 3
            </div>
            <div class="nav-item" data-view="cage4">
                ðŸ”§ Main System
            </div>
            <!-- Add Important Dates tab to navigation -->
            <div class="nav-item" data-view="important-dates">
                ðŸ“… Important Dates
            </div>
            
            <button class="logout-btn" onclick="logout()">Logout</button>
        </div>
        
        <div class="main-content">
            <!-- Move Important Dates view to the top of main-content, matching other views -->
            <div id="important-dates-view" style="display: none;">
                <div class="do-chart-container" style="border: 3px solid #27ae60; background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%); position: relative;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                        <div>
                            <h3 style="color: #27ae60; font-size: 22px; font-weight: bold; margin: 0;">Important Dates</h3>
                            <div style="display: flex; gap: 20px; align-items: center; margin-top: 10px;">
                                <label for="important-cage-select">Select Cage:</label>
                                <select id="important-cage-select">
                                    <option value="cage1">Cage 1</option>
                                    <option value="cage2">Cage 2</option>
                                    <option value="cage3">Cage 3</option>
                                </select>
                                <label for="important-date-select">Select Date:</label>
                                <select id="important-date-select">
                                    <option value="2025-06-04">June 4, 2025</option>
                                    <option value="2025-06-11">June 11, 2025</option>
                                    <option value="2025-06-15">June 15, 2025</option>
                                    <option value="2025-06-18">June 18, 2025</option>
                                    <option value="2025-06-21">June 21, 2025</option>
                                    <option value="2025-06-25">June 25, 2025</option>
                                    <option value="2025-07-02">July 2, 2025</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="important-dates-do-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="header">
                <h2 id="page-title">Dashboard Overview</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="refresh-btn" onclick="refreshDataAndCharts()" style="background: #3498db; color: white; border: none; padding: 8px 15px; border-radius: 5px; font-size: 14px; font-weight: bold; cursor: pointer;">
                        ðŸ”„ Refresh Data
                    </button>
                    <div id="connection-status" style="display: none; background: #f39c12; color: white; padding: 8px 15px; border-radius: 5px; font-size: 14px; font-weight: bold;">
                        ðŸ¤– DEMO MODE - Simulated Data
                    </div>
                </div>
            </div>
            
            <div id="dashboard-view">
                <!-- Dashboard Time Range Selector -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="color: #2c3e50; font-size: 18px; font-weight: bold; margin: 0;">ðŸ“Š Dashboard Time Range</h3>
                    <div class="time-range-selector">
                        <select id="dashboard-time-range" onchange="updateDashboardTimeRange(this.value)">
                            <option value="realtime" selected>Last 3 Minutes</option>
                            <option value="1h">Last Hour</option>
                            <option value="3h">Last 3 Hours</option>
                            <option value="6h">Last 6 Hours</option>
                            <option value="12h">Last 12 Hours</option>
                            <option value="1d">Last 1 Day</option>
                        </select>
                    </div>
                </div>
                
                <div class="do-chart-container" style="border: 3px solid #27ae60; background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%); position: relative;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                        <div>
                            <h3 style="color: #27ae60; font-size: 22px; font-weight: bold; margin: 0;">ðŸŒŠ DISSOLVED OXYGEN LEVELS - CRITICAL MONITORING</h3>
                            <p style="color: #2d5f3f; margin: 5px 0 0 0; font-weight: 500;">Real-time water quality across all active cages</p>
                        </div>
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="do-overview-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="cage-view" style="display: none;">
                <div class="cage-card">
                    <h3 id="cage-title">Cage Details</h3>
                    <div class="stats-grid" id="cage-stats">
                        <!-- New Stats UI -->
                        <div class="stat-item">
                            <div class="stat-value" id="detail-aerator">--</div>
                            <div class="stat-label">Aerator</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="detail-do">--</div>
                            <div class="stat-label">DO (mg/L)</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="detail-voltage">--</div>
                            <div class="stat-label">Voltage (V)</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="detail-current">--</div>
                            <div class="stat-label">Current (A)</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="detail-battery">100%</div>
                            <div class="stat-label">Battery</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="detail-clock">--</div>
                            <div class="stat-label">Last Update</div>
                        </div>
                    </div>
                    <!-- Global Time Range Selector for Cage -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <h3 style="color: #2c3e50; font-size: 18px; font-weight: bold; margin: 0;">ðŸ“Š Chart Time Range</h3>
                        <div class="time-range-selector">
                            <select id="cage-time-range" onchange="updateCageTimeRange(this.value)">
                                <option value="realtime" selected>Last 3 Minutes</option>
                                <option value="1h">Last Hour</option>
                                <option value="3h">Last 3 Hours</option>
                                <option value="6h">Last 6 Hours</option>
                                <option value="12h">Last 12 Hours</option>
                                <option value="1d">Last 1 Day</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h3 style="color: #2c3e50; font-size: 18px; font-weight: bold; margin-bottom: 15px;">ðŸ“ˆ Voltage & Current Monitoring</h3>
                        <canvas id="cage-chart"></canvas>
                    </div>
                    <div class="do-chart-container" id="cage-do-chart-container" style="display: none; border: 3px solid #27ae60; background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%); position: relative;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 10px;">
                            <h3 style="color: #27ae60; font-size: 20px; font-weight: bold; margin: 0;">ðŸŒŠ DISSOLVED OXYGEN LEVEL</h3>
                            <div style="display: flex; gap: 10px;">
                                <button class="download-btn-prominent" id="download-csv" onclick="downloadCurrentTimeRange()">
                                    ðŸ“¥ Download Data
                                </button>
                                <button class="download-btn-prominent" id="download-past-month" onclick="downloadPastMonth(event)">
                                    ðŸ“… Download Past Month
                                </button>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="cage-do-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Modal -->
    <div id="downloadModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ðŸ“¥ Download Data Range</h3>
                <span class="close" onclick="closeDownloadModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="start-date">Start Date & Time:</label>
                    <input type="datetime-local" id="start-date" value="2025-06-04T00:00">
                </div>
                <div class="form-group">
                    <label for="end-date">End Date & Time:</label>
                    <input type="datetime-local" id="end-date" value="2025-06-10T23:59">
                </div>
                <div class="form-group">
                    <label for="download-timeframe">Download Timeframe:</label>
                    <select id="download-timeframe" onchange="updateDownloadDates(this.value)">
                        <option value="custom">Custom Date Range</option>
                        <option value="realtime">Last 3 Minutes</option>
                        <option value="1h">Last Hour</option>
                        <option value="3h">Last 3 Hours</option>
                        <option value="6h">Last 6 Hours</option>
                        <option value="12h">Last 12 Hours</option>
                        <option value="1d">Last 1 Day</option>
                        <option value="2d">Last 2 Days</option>
                        <option value="3d">Last 3 Days</option>
                        <option value="1w">Last 1 Week</option>
                        <option value="2w">Last 2 Weeks</option>
                        <option value="3w">Last 3 Weeks</option>
                        <option value="1m">Last 1 Month</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="cage-select">Select Cage:</label>
                    <select id="cage-select">
                        <option value="cage1">Cage 1</option>
                        <option value="cage2">Cage 2</option>
                        <option value="cage3">Cage 3</option>
                        <option value="cage4">Main System</option>
                    </select>
                </div>
                <div class="form-actions">
                    <button class="btn-cancel" onclick="closeDownloadModal()">Cancel</button>
                    <button class="btn-save" onclick="downloadDateRange()">Download CSV</button>
                </div>
                <div id="download-message" class="message" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentView = 'dashboard';
        let cageData = {};
        let charts = {};
        let cageChart = null;
        let doOverviewChart = null;
        let allCageData = {}; // Stores all loaded CSV data
        let realTimeDataIndex = {}; // Tracks position in future data for real-time simulation
        let previousAverages = {};
        
        // Initialize application
        document.addEventListener('DOMContentLoaded', async function() {
            // Check if user is logged in
            if (!checkLogin()) {
                window.location.href = '/login.html';
                return;
            }
            
            initializeNavigation();
            initializeDOOverviewChart();
            setUserInfo();
            
            // Load data and then populate charts
            await loadAllCageData();
            
            // Immediately populate the dashboard chart with historical data
            console.log('ðŸ”„ All cage data loaded, initializing dashboard with historical data...');
            console.log('ðŸ“Š Available cage data:', Object.keys(allCageData).map(cage => `${cage}: ${allCageData[cage].length} records`));
            
            console.log('âœ… Data loaded successfully');
            
            setTimeout(() => {
                refreshDashboardChart();
                console.log('ðŸŽ¯ Dashboard initialized with historical data');
                
                // Also populate the dashboard with current data immediately
                populateChartsWithCurrentData();
                
                // Start real-time chart updates (every 1 second)
                startRealTimeUpdates();
            }, 100);
        });
        
        // Simple login check
        function checkLogin() {
            return sessionStorage.getItem('aquasense_logged_in') === 'true';
        }
        
        // Set user info
        function setUserInfo() {
            const username = sessionStorage.getItem('aquasense_username') || 'Admin';
            document.getElementById('user-name').textContent = username;
        }
        
        // Logout function
        window.logout = function() {
            sessionStorage.removeItem('aquasense_logged_in');
            sessionStorage.removeItem('aquasense_username');
            window.location.href = '/login.html';
        }
        
        // Load all cage data from CSV files
        async function loadAllCageData() {
            console.log('ðŸ“ Loading cage data from CSV files...');
            
            const cages = [
                { key: 'cage1', file: 'new_data/4 deci cage 1.csv' },
                { key: 'cage2', file: 'new_data/4 deci cage 2.csv' },
                { key: 'cage3', file: 'new_data/4 deci cage 3.csv' },
                { key: 'cage4', file: 'new_data/4 deci main system.csv' }
            ];
            
            for (const cage of cages) {
                try {
                    console.log(`Loading ${cage.file}...`);
                    const response = await fetch(`${cage.file}`);
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load ${cage.file}: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log(`ðŸ“„ Loaded ${cage.file}: ${csvText.length} characters`);
                    
                    const data = parseCSV(csvText, cage.key !== 'cage4');
                    allCageData[cage.key] = data;
                    
                    console.log(`âœ… Parsed ${cage.key}: ${data.length} records`);
                    
                    console.log(`âœ… Loaded ${data.length} records for ${cage.key}`);
                    if (data.length > 0) {
                        const startDate = new Date(data[0].timestamp);
                        const endDate = new Date(data[data.length - 1].timestamp);
                        console.log(`   Range: ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`);
                    }
                    
                    // Initialize real-time data index near the end for simulation
                    // Start from a recent point to provide continuous data
                    realTimeDataIndex[cage.key] = Math.max(0, data.length - 50);
                    
                } catch (error) {
                    console.error(`âŒ Error loading ${cage.file}:`, error);
                    allCageData[cage.key] = [];
                    realTimeDataIndex[cage.key] = 0;
                }
            }
            
            // Show live data indicator
            const statusIndicator = document.getElementById('connection-status');
            if (statusIndicator) {
                statusIndicator.textContent = 'ðŸ“Š LIVE DATA - Real Sensor Readings';
                statusIndicator.style.background = '#27ae60';
                statusIndicator.style.display = 'block';
            }
            
            console.log('ðŸ“Š CSV data loading complete');
        }
        
        // Refresh CSV data and update charts
        async function refreshDataAndCharts() {
            console.log('ðŸ”„ Refreshing CSV data and updating charts...');
            
            // Show loading state
            const refreshBtn = document.getElementById('refresh-btn');
            const originalText = refreshBtn.innerHTML;
            refreshBtn.innerHTML = 'â³ Refreshing...';
            refreshBtn.disabled = true;
            
            try {
                // Reload CSV data
                await loadAllCageData();
                
                // Repopulate charts with fresh data
                populateChartsWithInitialData();
                
                // Update the current view
                if (currentView === 'dashboard') {
                    refreshDashboardChart();
                } else if (currentView && currentView !== 'dashboard') {
                    // Update the current cage view
                    loadAndRefreshCageData(currentView);
                }
                
                console.log('âœ… Data refresh complete');
                
                // Update status indicator
                const statusIndicator = document.getElementById('connection-status');
                if (statusIndicator) {
                    statusIndicator.textContent = 'ðŸ“Š LIVE DATA - Updated ' + new Date().toLocaleTimeString();
                }
                
            } catch (error) {
                console.error('âŒ Error refreshing data:', error);
            } finally {
                // Restore button state
                refreshBtn.innerHTML = originalText;
                refreshBtn.disabled = false;
            }
        }
        
        // Auto-refresh data every 1 second
        function startAutoRefresh() {
            console.log('â° Starting auto-refresh (every 1 second)...');
            setInterval(refreshDataAndCharts, 1000); // 1 second
        }
        
        // Continuous real-time chart updates
        function startRealTimeUpdates() {
            console.log('â° Starting real-time chart updates (every 1 second)...');
            
            setInterval(() => {
                const now = Date.now();
                console.log(`ðŸ• Real-time update: ${new Date(now).toLocaleString()}`);
                
                // Update current data for all cages based on current time
                updateCurrentDataFromCSV(now);
                
                // Always update the currently visible charts
                if (currentView === 'dashboard') {
                    updateDashboardChartsRealTime(now);
                } else if (currentView && currentView !== 'dashboard') {
                    updateCageChartsRealTime(currentView, now);
                }
                
            }, 1000); // Update every second
        }
        
        // Update current data from CSV based on current time
        function updateCurrentDataFromCSV(currentTime) {
            ['cage1', 'cage2', 'cage3', 'cage4'].forEach(cage => {
                const data = allCageData[cage];
                if (!data || data.length === 0) return;
                
                // Only consider data points with timestamp <= current time
                const validData = data.filter(record => record.timestamp <= currentTime);
                if (validData.length === 0) return;
                
                // Find the data point closest to the current time
                const closest = validData.reduce((prev, current) => {
                    return Math.abs(current.timestamp - currentTime) < Math.abs(prev.timestamp - currentTime) ? current : prev;
                });
                
                // Update current data
                cageData[cage] = {
                    ...closest,
                    timestamp: closest.timestamp
                };
                
                // Update history for the selected timeframe
                const timeRangeMs = getTimeRangeInMilliseconds(currentTimeRange);
                const targetStartTime = currentTime - timeRangeMs;
                
                // Get data within the timeframe up to current time, only valid timestamps
                const timeframeData = validData.filter(record => 
                    record.timestamp >= targetStartTime && record.timestamp <= currentTime
                );
                
                if (timeframeData.length > 0) {
                    cageData[cage + '_history'] = timeframeData;
                } else {
                    // Fallback to data around the closest point
                    const closestIndex = validData.findIndex(record => record.timestamp === closest.timestamp);
                    const pointsNeeded = Math.min(50, validData.length);
                    const startIndex = Math.max(0, closestIndex - pointsNeeded + 1);
                    cageData[cage + '_history'] = validData.slice(startIndex, closestIndex + 1);
                }
            });
        }
        
        // Update dashboard charts in real-time
        function updateDashboardChartsRealTime(currentTime) {
            if (!doOverviewChart) return;
            
            // Reload fresh data from CSV and update the dashboard
            refreshDashboardChart();
            
            // Update stats display
            updateDashboardStats();
        }
        
        // Update individual cage charts in real-time
        function updateCageChartsRealTime(cage, currentTime) {
            // Reload fresh data for the cage
            loadAndRefreshCageData(cage);
            
            // Update stats display
            updateCageStats(cage);
        }
        
        // Update cage stats display
        function updateCageStats(cage, dataOverride) {
            const data = allCageData[cage];
            const aeratorEl = document.getElementById('detail-aerator');
            const voltageEl = document.getElementById('detail-voltage');
            const currentEl = document.getElementById('detail-current');
            const batteryEl = document.getElementById('detail-battery');
            const doEl = document.getElementById('detail-do');
            const clockEl = document.getElementById('detail-clock');
            if (!data || data.length === 0) {
                if (aeratorEl) aeratorEl.textContent = '--';
                if (voltageEl) voltageEl.textContent = '--';
                if (currentEl) currentEl.textContent = '--';
                if (batteryEl) batteryEl.textContent = '100%';
                if (doEl && cage !== 'cage4') doEl.textContent = '--';
                if (clockEl) clockEl.textContent = '--';
                return;
            }
            let currentData = dataOverride;
            if (!currentData) {
                const now = Date.now();
                const validData = data.filter(record => record.timestamp <= now);
                if (validData.length > 0) {
                    currentData = validData.reduce((prev, current) => {
                        return Math.abs(current.timestamp - now) < Math.abs(prev.timestamp - now) ? current : prev;
                    });
                } else {
                    currentData = data[data.length - 1];
                }
            }
            function formatValue(val) {
                return (typeof val === 'number' && isFinite(val)) ? val.toFixed(2) : '--';
            }
            if (aeratorEl) aeratorEl.textContent = currentData.aerator || '--';
            if (voltageEl) voltageEl.textContent = formatValue(currentData.voltage);
            if (currentEl) currentEl.textContent = formatValue(currentData.current);
            if (batteryEl) batteryEl.textContent = '100%';
            if (doEl && cage !== 'cage4' && typeof currentData.do === 'number' && isFinite(currentData.do)) {
                doEl.textContent = formatValue(currentData.do);
            } else if (doEl && cage !== 'cage4') {
                doEl.textContent = '--';
            }
            if (clockEl) clockEl.textContent = new Date().toLocaleString();
        }
        
        // Update dashboard stats display
        function updateDashboardStats() {
            ['cage1', 'cage2', 'cage3'].forEach(cage => {
                const currentData = cageData[cage];
                if (!currentData) return;
                
                const voltageEl = document.getElementById(`${cage}-voltage`);
                const currentEl = document.getElementById(`${cage}-current`);
                const batteryEl = document.getElementById(`${cage}-battery`);
                const doEl = document.getElementById(`${cage}-do`);
                const timestampEl = document.getElementById(`${cage}-timestamp`);
                
                if (voltageEl) voltageEl.textContent = (currentData.voltage || 0).toFixed(2);
                if (currentEl) currentEl.textContent = (currentData.current || 0).toFixed(2);
                if (batteryEl) batteryEl.textContent = (currentData.battery || 0).toFixed(2);
                if (doEl) doEl.textContent = (currentData.do || 0).toFixed(2);
                if (timestampEl) timestampEl.textContent = new Date(currentData.timestamp).toLocaleString();
            });
        }
        
        // Populate charts with initial data based on current real time
        function populateChartsWithInitialData() {
            console.log('ðŸš€ Populating charts with initial data...');
            const now = Date.now(); // Use real wall clock time
            console.log(`ðŸ• Current time: ${new Date(now).toLocaleString()}`);
            
            ['cage1', 'cage2', 'cage3', 'cage4'].forEach(cage => {
                const data = allCageData[cage];
                if (data && data.length > 0) {
                    console.log(`ðŸ“Š Setting up data for ${cage} (timeframe: ${currentTimeRange})`);
                    
                    // Calculate target time range from current time backwards
                    const timeRangeMs = getTimeRangeInMilliseconds(currentTimeRange);
                    const targetEndTime = now;
                    const targetStartTime = now - timeRangeMs;
                    
                    console.log(`ðŸ” ${cage}: Looking for CSV data from ${new Date(targetStartTime).toLocaleString()} to ${new Date(targetEndTime).toLocaleString()}`);
                    
                    // First, try to get data within the exact time range
                    let csvTimeframeData = data.filter(record => 
                        record.timestamp >= targetStartTime && 
                        record.timestamp <= targetEndTime
                    );
                    
                    // If no data in exact timeframe, get the most recent data available
                    if (csvTimeframeData.length === 0) {
                        console.log(`âš ï¸ ${cage}: No data in exact timeframe, getting most recent data`);
                        
                        // Get the most recent data points (up to 50 points)
                        const recentData = data.slice(-50);
                        csvTimeframeData = recentData;
                        
                        console.log(`âœ… ${cage}: Using ${recentData.length} most recent records`);
                    }
                    
                    // Store in cage history for charts
                    if (!cageData[cage + '_history']) {
                        cageData[cage + '_history'] = [];
                    }
                    cageData[cage + '_history'] = [...csvTimeframeData];
                    
                    // Set current data to the most recent data point
                    if (csvTimeframeData.length > 0) {
                        cageData[cage] = {
                            ...csvTimeframeData[csvTimeframeData.length - 1],
                            timestamp: csvTimeframeData[csvTimeframeData.length - 1].timestamp
                        };
                    }
                    
                    console.log(`âœ… ${cage}: ${currentTimeRange} data (${csvTimeframeData.length} points) from ${csvTimeframeData.length > 0 ? new Date(csvTimeframeData[0].timestamp).toLocaleString() : 'N/A'} to ${csvTimeframeData.length > 0 ? new Date(csvTimeframeData[csvTimeframeData.length - 1].timestamp).toLocaleString() : 'N/A'}`);
                }
            });
            
            // Force update all charts with the initial data
            if (doOverviewChart) {
                refreshDashboardChart();
            }
            
            console.log('ðŸŽ¯ Initial data population complete');
        }
        
        // Populate charts with current data immediately for dashboard
        function populateChartsWithCurrentData() {
            console.log('ðŸš€ Populating dashboard with current data...');
            
            const now = Date.now();
            
            ['cage1', 'cage2', 'cage3'].forEach(cage => {
                // Use the current data that was already set by populateChartsWithInitialData
                if (cageData[cage]) {
                    const currentRecord = cageData[cage];
                    
                    // Update DO overview chart if this cage has DO data
                    if (currentRecord.do !== undefined && currentRecord.do !== null) {
                        updateDOOverviewChart(cage, currentRecord);
                    }
                    
                    console.log(`âœ… Dashboard data for ${cage}: DO=${currentRecord.do?.toFixed(1)}, time=${new Date(currentRecord.timestamp).toLocaleString()}`);
                }
            });
            
            console.log('ðŸŽ¯ Dashboard data population complete');
        }
        
        // Parse CSV data
        function parseCSV(csvText, hasDO = true) {
            const lines = csvText.trim().split('\n');
            const data = [];
            let lastAerator = null;
            for (let i = 1; i < lines.length; i++) { // Skip header
                const values = lines[i].split(',');
                if (values.length >= 4) {
                    const timestamp = new Date(values[0]).getTime();
                    if (!isNaN(timestamp)) {
                        const record = {
                            timestamp: timestamp,
                            voltage: parseFloat(values[hasDO ? 2 : 1]),
                            current: parseFloat(values[hasDO ? 3 : 2]),
                            battery: parseFloat(values[hasDO ? 4 : 3])
                        };
                        if (hasDO) {
                            record.do = parseFloat(values[1]);
                        }
                        // Aerator ON/OFF logic
                        const aeratorCol = values[hasDO ? 5 : 4];
                        if (aeratorCol && aeratorCol.trim().toUpperCase().includes('AERATOR')) {
                            if (aeratorCol.toUpperCase().includes('ON')) {
                                lastAerator = 'ON';
                            } else if (aeratorCol.toUpperCase().includes('OFF')) {
                                lastAerator = 'OFF';
                            }
                        }
                        record.aerator = lastAerator;
                        // Only add valid records
                        if (!isNaN(record.voltage) && !isNaN(record.current) && !isNaN(record.battery) &&
                            (!hasDO || !isNaN(record.do))) {
                            data.push(record);
                        }
                    }
                }
            }
            return data.sort((a, b) => a.timestamp - b.timestamp);
        }
        
        // No longer needed - all timeframes use the same static data loading logic
        
        // Navigation handling
        function initializeNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                item.addEventListener('click', function() {
                    const view = this.dataset.view;
                    switchView(view);
                });
            });
        }
        

        

        
        // Load historical data from JSON endpoints
        async function loadHistoricalData() {
            const cages = ['cage1', 'cage2', 'cage3', 'cage4'];
            
            for (const cage of cages) {
                try {
                    const response = await fetch(`/${cage}`);
                    const jsonData = await response.json();
                    
                    historicalData[cage] = jsonData.map(row => ({
                        timestamp: typeof row.timestamp === 'string' ? new Date(row.timestamp).getTime() : row.timestamp,
                        do: row.do,
                        voltage: row.voltage,
                        current: row.current,
                        battery: row.battery
                    }));
                    
                    console.log(`Loaded ${historicalData[cage].length} records for ${cage}`);
                } catch (error) {
                    console.error(`Error loading ${cage} data:`, error);
                    historicalData[cage] = [];
                }
            }
        }
        
        // Load initial DO data for the chart
        function loadInitialDOData() {
            if (!doOverviewChart) {
                console.log('DO overview chart not found');
                return;
            }
            
            console.log('Loading initial DO data for overview chart');
            
            const cages = ['cage1', 'cage2', 'cage3'];
            
            // Load data for each cage using the current time range
            cages.forEach((cage, index) => {
                const data = allCageData[cage] || [];
                
                // Use historical data ending at July 10, 2025
                const july10 = new Date('2025-07-10T00:00:00').getTime();
                const historicalData = data.filter(record => record.timestamp <= july10);
                const filteredData = filterDataByTimeRange(historicalData, currentTimeRange, july10);
                const processedData = ensureDataSpansTimeRange(filteredData, currentTimeRange, cage);
                
                // Get data with valid DO values
                const recentData = processedData
                    .filter(d => d.do !== undefined && d.do !== null && !isNaN(d.do))
                    .map(d => ({
                        x: new Date(d.timestamp),
                        y: d.do
                    }));
                
                doOverviewChart.data.datasets[index].data = recentData;
                console.log(`Loaded ${recentData.length} DO values for ${cage}`);
            });
            
            // Update chart time bounds
            updateChartTimeBounds(doOverviewChart, currentTimeRange);
            
            // Update point visibility based on current time range
            updateChartPointVisibility(doOverviewChart, currentTimeRange);
            
            // Update with no animation for initial load
            doOverviewChart.update('none');
            console.log('DO overview chart updated with initial data');
        }
        
        // Initialize DO overview chart
        function initializeDOOverviewChart() {
            const ctx = document.getElementById('do-overview-chart').getContext('2d');
            
            doOverviewChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Cage 1',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 4, // Default for real-time mode
                            pointHoverRadius: 6,
                            spanGaps: true
                        },
                        {
                            label: 'Cage 2',
                            data: [],
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 4, // Default for real-time mode
                            pointHoverRadius: 6,
                            spanGaps: true
                        },
                        {
                            label: 'Cage 3',
                            data: [],
                            borderColor: '#27ae60',
                            backgroundColor: 'rgba(39, 174, 96, 0.1)',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 4, // Default for real-time mode
                            pointHoverRadius: 6,
                            spanGaps: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: 'Real-time DO Monitoring'
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            min: 2.2,
                            max: 3.2,
                            title: {
                                display: true,
                                text: 'Dissolved Oxygen (mg/L)'
                            }
                        }
                    },
                    parsing: {
                        xAxisKey: 'x',
                        yAxisKey: 'y'
                    },
                    animation: {
                        duration: 0  // Disable animations
                    }
                }
            });
            
            // Dashboard chart will be populated after data loads
        }
        
        // Initialize chart for a cage
        function initializeCageChart(cage) {
            const ctx = document.getElementById(`${cage}-chart`).getContext('2d');
            const datasets = [
                {
                    label: 'Voltage (V)',
                    data: [],
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    tension: 0.4
                },
                {
                    label: 'Current (A)',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    tension: 0.4
                }
            ];
            
            // Add DO dataset for cages 1-3
            if (cage !== 'cage4') {
                datasets.push({
                    label: 'DO (mg/L)',
                    data: [],
                    borderColor: '#27ae60',
                    backgroundColor: 'rgba(39, 174, 96, 0.1)',
                    tension: 0.4
                });
            }
            
            charts[cage] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm'
                                }
                            },

                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
            
            // Load comprehensive data for the cage
            setTimeout(() => {
                loadAndRefreshCageData(cage);
            }, 100);
        }
        
        // Load recent data for cage chart
        function loadRecentDataForCage(cage) {
            const now = Date.now();
            const thirtySecondsAgo = now - 30000;
            
            // Get chart reference
            const chart = charts[cage];
            if (!chart) return;
            
            // Create history array if it doesn't exist
            if (!cageData[cage + '_history']) {
                cageData[cage + '_history'] = [];
            }
            
            // Load recent data
            const recentData = cageData[cage + '_history'].slice(-50); // Get last 50 points
            
            // Populate chart with recent data
            recentData.forEach(data => {
                const time = new Date(data.timestamp);
                chart.data.labels.push(time);
                chart.data.datasets[0].data.push(data.voltage || 0);
                chart.data.datasets[1].data.push(data.current || 0);
                
                // Add DO data for cages 1-3
                if (cage !== 'cage4' && chart.data.datasets[2]) {
                    chart.data.datasets[2].data.push(data.do || 0);
                }
            });
            
            chart.update('none');
            console.log(`Loaded ${recentData.length} recent data points for ${cage}`);
        }
        
        // Update cage data
        function updateCageData(cage, data) {
            cageData[cage] = data;
            
            // Store historical data for charts
            if (!cageData[cage + '_history']) {
                cageData[cage + '_history'] = [];
            }
            
            // Add current data to history
            cageData[cage + '_history'].push(data);
            
            // Keep only last 100 data points for performance
            if (cageData[cage + '_history'].length > 100) {
                cageData[cage + '_history'].shift();
            }
            
            // ALWAYS update DO overview chart for dashboard (regardless of current view)
            if (data.do !== undefined && data.do !== null) {
                updateDOOverviewChart(cage, data);
            }
            
            // ALWAYS update cage-specific charts (regardless of current view)
            // This ensures data keeps updating even when not viewing the specific cage
            updateCageStats(cage, data);
            
            // Update cage voltage/current chart if it exists
            if (currentView === cage && cageChart) {
                updateCageChart(cage, data);
            }
            
            // Update detailed view stats if currently viewing this cage
            if (currentView === cage) {
                updateDetailedView(cage, data);
            }
            
            // Update individual cage DO chart if it exists and we're viewing this cage
            if (currentView === cage && data.do !== undefined && data.do !== null && window.cageDOChart) {
                updateCageDOChart(cage, data);
            }
            
            console.log(`ðŸ“Š Real-time data updated for ${cage}: DO=${data.do?.toFixed(1)}, V=${data.voltage?.toFixed(1)}, A=${data.current?.toFixed(2)}`);
        }
        
        // Update DO overview chart
        function updateDOOverviewChart(cage, data) {
            if (!doOverviewChart) {
                console.log('DO overview chart not available for update');
                return;
            }
            
            console.log(`Updating DO overview chart for ${cage} with DO: ${data.do}`);
            
            const time = new Date(data.timestamp);
            const cageIndex = cage === 'cage1' ? 0 : cage === 'cage2' ? 1 : 2;
            
            if (cageIndex < 0 || cageIndex > 2) {
                console.log(`Invalid cage for DO chart: ${cage}`);
                return;
            }
            
            // Check if this data point is within the current time range
            const cutoffTime = Date.now() - getTimeRangeInMilliseconds(currentTimeRange);
            if (data.timestamp >= cutoffTime) {
                // Add the new data point directly to the specific cage dataset
                const dataset = doOverviewChart.data.datasets[cageIndex];
                
                // Add the data point as an object with x (time) and y (value)
                dataset.data.push({
                    x: time,
                    y: data.do
                });
                
                // Only remove points for real-time mode, preserve historical data for other time ranges
                let pointsRemoved = 0;
                if (currentTimeRange === 'realtime') {
                    const now = Date.now();
                    const newCutoffTime = now - getTimeRangeInMilliseconds(currentTimeRange);
                    const newStartTime = newCutoffTime; // This is our new left boundary
                    
                    while (dataset.data.length > 0 && 
                           dataset.data[0].x.getTime() < newCutoffTime) {
                        dataset.data.shift();
                        pointsRemoved++;
                    }
                }
                
                // If we removed points and now have a gap at the start, add a boundary point (only for real-time)
                if (pointsRemoved > 0 && dataset.data.length > 0 && currentTimeRange === 'realtime') {
                    const now = Date.now();
                    const newCutoffTime = now - getTimeRangeInMilliseconds(currentTimeRange);
                    const newStartTime = newCutoffTime;
                    const firstPointTime = dataset.data[0].x.getTime();
                    const gapAtStart = firstPointTime - newStartTime;
                    
                    if (gapAtStart > 60000) { // If there's more than 1 minute gap at start
                        // Add a boundary point at the new start time using the first data point's values
                        const boundaryPoint = {
                            x: new Date(newStartTime),
                            y: dataset.data[0].y
                        };
                        
                        dataset.data.unshift(boundaryPoint);
                        console.log(`Added new boundary point for ${cage} at dashboard time range start`);
                    }
                }
                
                // Update the chart with proper time bounds
                updateChartTimeBounds(doOverviewChart, currentTimeRange);
                
                // Auto-adjust y-axis range if needed
                adjustDOYAxisRange(doOverviewChart);
                
                // Make sure point visibility is correct for current time range
                updateChartPointVisibility(doOverviewChart, currentTimeRange);
                
                // Update the chart without animation to prevent glitches
                doOverviewChart.update('none');
                
                console.log(`DO overview chart updated for ${cage}. Points: ${dataset.data.length}, removed ${pointsRemoved} old points`);
            } else {
                console.log('New data point is outside current time range, not adding to overview chart');
            }
        }
        
        // Update cage statistics
        function updateCageStats(cage, dataOverride) {
            const data = allCageData[cage];
            const aeratorEl = document.getElementById('detail-aerator');
            const voltageEl = document.getElementById('detail-voltage');
            const currentEl = document.getElementById('detail-current');
            const batteryEl = document.getElementById('detail-battery');
            const doEl = document.getElementById('detail-do');
            const clockEl = document.getElementById('detail-clock');
            if (!data || data.length === 0) {
                if (aeratorEl) aeratorEl.textContent = '--';
                if (voltageEl) voltageEl.textContent = '--';
                if (currentEl) currentEl.textContent = '--';
                if (batteryEl) batteryEl.textContent = '100%';
                if (doEl && cage !== 'cage4') doEl.textContent = '--';
                if (clockEl) clockEl.textContent = '--';
                return;
            }
            let currentData = dataOverride;
            if (!currentData) {
                const now = Date.now();
                const validData = data.filter(record => record.timestamp <= now);
                if (validData.length > 0) {
                    currentData = validData.reduce((prev, current) => {
                        return Math.abs(current.timestamp - now) < Math.abs(prev.timestamp - now) ? current : prev;
                    });
                } else {
                    currentData = data[data.length - 1];
                }
            }
            function formatValue(val) {
                return (typeof val === 'number' && isFinite(val)) ? val.toFixed(2) : '--';
            }
            if (aeratorEl) aeratorEl.textContent = currentData.aerator || '--';
            if (voltageEl) voltageEl.textContent = formatValue(currentData.voltage);
            if (currentEl) currentEl.textContent = formatValue(currentData.current);
            if (batteryEl) batteryEl.textContent = '100%';
            if (doEl && cage !== 'cage4' && typeof currentData.do === 'number' && isFinite(currentData.do)) {
                doEl.textContent = formatValue(currentData.do);
            } else if (doEl && cage !== 'cage4') {
                doEl.textContent = '--';
            }
            if (clockEl) clockEl.textContent = new Date().toLocaleString();
        }
        
        // Update cage chart
        function updateCageChart(cage, data) {
            if (!cageChart) return;
            
            // Check if this data point is within the current time range
            const cutoffTime = Date.now() - getTimeRangeInMilliseconds(currentTimeRange);
            if (data.timestamp >= cutoffTime) {
                const time = luxon.DateTime.fromMillis(data.timestamp);
                
                // Add new data point
                cageChart.data.labels.push(time.toJSDate());
                cageChart.data.datasets[0].data.push(data.voltage);
                cageChart.data.datasets[1].data.push(data.current);
                
                // Only remove points for real-time mode, preserve historical data for other time ranges
                let pointsRemoved = 0;
                if (currentTimeRange === 'realtime') {
                    const now = Date.now();
                    const newCutoffTime = now - getTimeRangeInMilliseconds(currentTimeRange);
                    const newStartTime = newCutoffTime; // This is our new left boundary
                    
                    while (cageChart.data.labels.length > 0 && 
                           cageChart.data.labels[0].getTime() < newCutoffTime) {
                        cageChart.data.labels.shift();
                        cageChart.data.datasets.forEach(dataset => {
                            dataset.data.shift();
                        });
                        pointsRemoved++;
                    }
                }
                
                // If we removed points and now have a gap at the start, add a boundary point (only for real-time)
                if (pointsRemoved > 0 && cageChart.data.labels.length > 0 && currentTimeRange === 'realtime') {
                    const now = Date.now();
                    const newCutoffTime = now - getTimeRangeInMilliseconds(currentTimeRange);
                    const newStartTime = newCutoffTime;
                    const firstPointTime = cageChart.data.labels[0].getTime();
                    const gapAtStart = firstPointTime - newStartTime;
                    
                    if (gapAtStart > 60000) { // If there's more than 1 minute gap at start
                        // Add a boundary point at the new start time using the first data point's values
                        const boundaryPoint = {
                            timestamp: newStartTime,
                            voltage: cageChart.data.datasets[0].data[0],
                            current: cageChart.data.datasets[1].data[0]
                        };
                        
                        cageChart.data.labels.unshift(new Date(newStartTime));
                        cageChart.data.datasets[0].data.unshift(boundaryPoint.voltage);
                        cageChart.data.datasets[1].data.unshift(boundaryPoint.current);
                        console.log(`Added new boundary point at time range start to maintain coverage`);
                    }
                }
                
                // Update the chart with proper time bounds
                updateChartTimeBounds(cageChart, currentTimeRange);
                
                // Make sure point visibility is correct for current time range
                updateChartPointVisibility(cageChart, currentTimeRange);
                
                // Update the chart without animation to prevent glitches
                cageChart.update('none');
                
                console.log(`Voltage/Current chart updated for ${cage}. Total points: ${cageChart.data.labels.length}, removed ${pointsRemoved} old points`);
            } else {
                console.log('New data point is outside current time range, not adding to voltage/current chart');
            }
        }
        
        // Refresh all charts for a cage with current time range
        async function refreshCageCharts(cage) {
            await loadAndRefreshCageData(cage);
        }
        
        // Load fresh data from CSV files and refresh charts
        async function loadAndRefreshCageData(cage) {
            try {
                console.log(`ðŸ”„ Refreshing cage ${cage} with fresh data for ${currentTimeRange}`);
                
                // Use the same logic as dashboard - load data with current time-based approach
                loadDetailedHistoricalData(cage);
                
                // Also update the DO chart if it exists
                if (cage !== 'cage4' && window.cageDOChart) {
                    loadDOHistoricalData(cage);
                }
                
                console.log(`âœ… Cage ${cage}: Data refreshed successfully`);
            } catch (error) {
                console.error(`Error loading data for ${cage}:`, error);
            }
        }
        
        // Update individual cage DO chart using proven pattern
        function updateCageDOChart(cage, newData) {
            if (!window.cageDOChart) {
                console.log('No cageDOChart found for update');
                return;
            }
            
            console.log(`Updating DO chart for ${cage} with data:`, newData);
            
            // Add new data point to our data store
            if (!cageData[cage + '_history']) {
                cageData[cage + '_history'] = [];
            }
            
            cageData[cage + '_history'].push(newData);
            
            // Keep only last 50 data points
            if (cageData[cage + '_history'].length > 50) {
                cageData[cage + '_history'].shift();
            }
            
            // Instead of replacing all data, just add the new data point to the existing chart
            // This preserves the historical data loaded by time range selection
            const time = new Date(newData.timestamp);
            
            // Check if this data point is within the current time range
            const cutoffTime = Date.now() - getTimeRangeInMilliseconds(currentTimeRange);
            if (newData.timestamp >= cutoffTime) {
                // Add the new data point to the chart
                window.cageDOChart.data.labels.push(time);
                window.cageDOChart.data.datasets[0].data.push(newData.do);
                
                // Only remove points for real-time mode, preserve historical data for other time ranges
                let pointsRemoved = 0;
                if (currentTimeRange === 'realtime') {
                    const now = Date.now();
                    const newCutoffTime = now - getTimeRangeInMilliseconds(currentTimeRange);
                    const newStartTime = newCutoffTime; // This is our new left boundary
                    
                    while (window.cageDOChart.data.labels.length > 0 && 
                           window.cageDOChart.data.labels[0].getTime() < newCutoffTime) {
                        window.cageDOChart.data.labels.shift();
                        window.cageDOChart.data.datasets[0].data.shift();
                        pointsRemoved++;
                    }
                }
                
                // If we removed points and now have a gap at the start, add a boundary point (only for real-time)
                if (pointsRemoved > 0 && window.cageDOChart.data.labels.length > 0 && currentTimeRange === 'realtime') {
                    const now = Date.now();
                    const newCutoffTime = now - getTimeRangeInMilliseconds(currentTimeRange);
                    const newStartTime = newCutoffTime;
                    const firstPointTime = window.cageDOChart.data.labels[0].getTime();
                    const gapAtStart = firstPointTime - newStartTime;
                    
                    if (gapAtStart > 60000) { // If there's more than 1 minute gap at start
                        // Add a boundary point at the new start time using the first data point's values
                        const boundaryDOValue = window.cageDOChart.data.datasets[0].data[0];
                        
                        window.cageDOChart.data.labels.unshift(new Date(newStartTime));
                        window.cageDOChart.data.datasets[0].data.unshift(boundaryDOValue);
                        console.log(`Added new DO boundary point at time range start to maintain coverage`);
                    }
                }
                
                // Update the chart with proper time bounds
                updateChartTimeBounds(window.cageDOChart, currentTimeRange);
                
                // Auto-adjust y-axis range if needed
                adjustDOYAxisRange(window.cageDOChart);
                
                // Make sure point visibility is correct for current time range
                updateChartPointVisibility(window.cageDOChart, currentTimeRange);
                
                // Update the chart without animation to prevent glitches
                window.cageDOChart.update('none');
                
                console.log(`DO chart updated. Total points: ${window.cageDOChart.data.labels.length}, removed ${pointsRemoved} old points`);
            } else {
                console.log('New data point is outside current time range, not adding to chart');
            }
        }
        
        // Refresh dashboard chart with fresh data from CSV files
        async function refreshDashboardChart() {
            if (!doOverviewChart) return;
            
            try {
                console.log('ðŸ”„ Refreshing dashboard chart with fresh data...');
                
                // Reload fresh data from CSV files
                await loadAllCageData();
                
                // Repopulate data with fresh CSV data
                populateChartsWithInitialData();
                
                // Load data for all cages
                const cages = ['cage1', 'cage2', 'cage3'];
                const allData = {};
                
                for (const cage of cages) {
                    const data = allCageData[cage] || [];
                    if (data.length === 0) {
                        allData[cage] = [];
                        continue;
                    }
                    
                    // Use current time as reference for ALL modes
                    const referenceTime = Date.now(); // Always use current time
                    const timeRangeMs = getTimeRangeInMilliseconds(currentTimeRange);
                    const endTime = referenceTime;
                    const startTime = referenceTime - timeRangeMs;
                    
                    // Get fresh data from CSV for the current time range
                    const freshData = data.filter(record => 
                        record.timestamp >= startTime && 
                        record.timestamp <= endTime
                    );
                    
                    allData[cage] = freshData;
                    console.log(`ðŸ“Š Dashboard ${cage}: ${freshData.length} fresh records for ${currentTimeRange} from ${new Date(startTime).toLocaleString()} to ${new Date(endTime).toLocaleString()}`);
                }
                
                // Update time axis configuration
                const timeConfig = getTimeAxisConfig(currentTimeRange);
                
                doOverviewChart.options.scales.x.time.unit = timeConfig.unit;
                doOverviewChart.options.scales.x.time.displayFormats = {
                    [timeConfig.unit]: timeConfig.format
                };
                doOverviewChart.options.scales.x.time.tooltipFormat = timeConfig.tooltipFormat;
                
                // Set time bounds based on current time for ALL modes
                const now = Date.now();
                const timeRangeMs = getTimeRangeInMilliseconds(currentTimeRange);
                const maxTime = now;
                const minTime = now - timeRangeMs;
                
                doOverviewChart.options.scales.x.min = new Date(minTime);
                doOverviewChart.options.scales.x.max = new Date(maxTime);
                
                // Clear existing data and repopulate with fresh data
                doOverviewChart.data.labels = [];
                doOverviewChart.data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                
                // Populate datasets for each cage using x,y format for time series
                cages.forEach((cage, index) => {
                    const cageData = allData[cage] || [];
                    console.log(`ðŸ” Processing ${cage}: ${cageData.length} total records`);
                    
                    const dataPoints = cageData
                        .filter(item => item.do !== undefined && item.do !== null && !isNaN(item.do))
                        .map(item => ({
                            x: new Date(item.timestamp),
                            y: parseFloat(item.do)
                        }));
                    
                    console.log(`ðŸ“Š ${cage} chart data: ${dataPoints.length} points with DO values`);
                    if (dataPoints.length > 0) {
                        console.log(`ðŸ“Š ${cage} first point:`, dataPoints[0]);
                        console.log(`ðŸ“Š ${cage} last point:`, dataPoints[dataPoints.length - 1]);
                    }
                    
                    if (doOverviewChart.data.datasets[index]) {
                        doOverviewChart.data.datasets[index].data = dataPoints;
                        console.log(`âœ… Set ${dataPoints.length} points for ${cage} dataset ${index}`);
                    } else {
                        console.warn(`âš ï¸ No dataset found for ${cage} at index ${index}`);
                    }
                });
                
                // Update point visibility based on current time range
                updateChartPointVisibility(doOverviewChart, currentTimeRange);
                
                // Update with no animation for refresh to prevent left side glitches
                doOverviewChart.update('none');
                
                console.log(`ðŸŽ¯ Dashboard chart update complete!`);
                console.log(`Dashboard DO chart refreshed with time range: ${currentTimeRange} (${new Date(minTime).toLocaleString()} to ${new Date(maxTime).toLocaleString()})`);
                
                // Final debug: Check what's actually in the chart
                doOverviewChart.data.datasets.forEach((dataset, i) => {
                    console.log(`ðŸ“ˆ Dataset ${i} (${['Cage 1', 'Cage 2', 'Cage 3'][i]}): ${dataset.data.length} points`);
                });
                
            } catch (error) {
                console.error('Error refreshing dashboard chart:', error);
            }
        }
        
        // Update overview statistics
        function updateOverview() {
            const cages = Object.keys(cageData);
            if (cages.length === 0) return;
            
            let totalDO = 0;
            let doCount = 0;
            let totalVoltage = 0;
            let totalBattery = 0;
            
            cages.forEach(cage => {
                const data = cageData[cage];
                if (data.do !== undefined) {
                    totalDO += data.do;
                    doCount++;
                }
                totalVoltage += data.voltage;
                totalBattery += data.battery;
            });
            
            const avgDO = doCount > 0 ? (totalDO / doCount) : 0;
            const avgVoltage = totalVoltage / cages.length;
            const avgBattery = totalBattery / cages.length;
            
            // Calculate trends
            const doTrend = calculateTrend('do', avgDO);
            const voltageTrend = calculateTrend('voltage', avgVoltage);
            const batteryTrend = calculateTrend('battery', avgBattery);
            
            // Update display
            document.getElementById('avg-do').textContent = doCount > 0 ? avgDO.toFixed(1) : '--';
            document.getElementById('avg-voltage').textContent = avgVoltage.toFixed(1);
            document.getElementById('avg-battery').textContent = avgBattery.toFixed(2);
            
            // Update trends
            document.getElementById('do-trend').textContent = doTrend;
            document.getElementById('voltage-trend').textContent = voltageTrend;
            document.getElementById('battery-trend').textContent = batteryTrend;
        }
        
        // Calculate trend indicator
        function calculateTrend(type, currentValue) {
            const previousValue = previousAverages[type];
            if (previousValue === undefined) {
                previousAverages[type] = currentValue;
                return '~';
            }
            
            const diff = currentValue - previousValue;
            previousAverages[type] = currentValue;
            
            if (Math.abs(diff) < 0.1) return '~';
            return diff > 0 ? `+${diff.toFixed(1)}` : diff.toFixed(1);
        }
        
        // Show cage details
        function showCageDetails(cage) {
            const cageTitle = document.getElementById('cage-title');
            const cageStats = document.getElementById('cage-stats');
            const downloadBtn = document.getElementById('download-csv');
            const downloadPastMonthBtn = document.getElementById('download-past-month');
            const doChartContainer = document.getElementById('cage-do-chart-container');
            
            if (cage === 'cage4') {
                cageTitle.textContent = 'Main System Details';
                downloadBtn.style.display = 'block'; // Show download button for Main System
                downloadBtn.onclick = () => downloadCurrentTimeRange();
                downloadPastMonthBtn.style.display = 'block'; // Show download button for Main System
                downloadPastMonthBtn.onclick = () => downloadPastMonth(event);
            } else {
                cageTitle.textContent = `${cage.charAt(0).toUpperCase() + cage.slice(1)} Details`;
                downloadBtn.style.display = 'block'; // Show download button for all cages
                downloadBtn.onclick = () => downloadCurrentTimeRange();
                downloadPastMonthBtn.style.display = 'block'; // Show download button for all cages
                downloadPastMonthBtn.onclick = () => downloadPastMonth(event);
            }
            
            // Show/hide DO chart container based on cage
            if (cage !== 'cage4') {
                doChartContainer.style.display = 'block';
            } else {
                doChartContainer.style.display = 'none';
            }
            
            // Update stats
            cageStats.innerHTML = '';
            const statsHTML = `
                <div class="stat-item">
                    <div class="stat-value" id="detail-aerator">--</div>
                    <div class="stat-label">Aerator</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="detail-do">--</div>
                    <div class="stat-label">DO (mg/L)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="detail-voltage">--</div>
                    <div class="stat-label">Voltage (V)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="detail-current">--</div>
                    <div class="stat-label">Current (A)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="detail-battery">100%</div>
                    <div class="stat-label">Battery</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="detail-clock">--</div>
                    <div class="stat-label">Last Update</div>
                </div>
            `;
            cageStats.innerHTML = statsHTML;
            // Immediately update stats after rendering the HTML
            updateCageStats(cage);
            
            // Initialize detailed charts with historical data
            initializeDetailedChart(cage);
            if (cage !== 'cage4') {
                initializeCageDOChart(cage);
            }
            
            // Load historical data for the charts immediately
            if (Object.keys(allCageData).length > 0) {
                // Data is already loaded, refresh immediately
                setTimeout(() => {
                    loadAndRefreshCageData(cage);
                    // Update statistics immediately
                    updateCageStats(cage);
                }, 100);
            } else {
                console.log('âš ï¸ Cage data not loaded yet, will refresh when available');
            }
            
            if (downloadBtn) downloadBtn.setAttribute('data-cage', cage);
            if (downloadPastMonthBtn) downloadPastMonthBtn.setAttribute('data-cage', cage);
        }
        
        // Initialize detailed chart for cage view
        function initializeDetailedChart(cage) {
            const ctx = document.getElementById('cage-chart').getContext('2d');
            
            if (cageChart) {
                cageChart.destroy();
            }
            
            const datasets = [
                {
                    label: 'Voltage (V)',
                    data: [],
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    tension: 0.4
                },
                {
                    label: 'Current (A)',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    tension: 0.4
                }
            ];
            
            cageChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: 'Voltage & Current Monitoring'
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm'
                                }
                            },

                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            beginAtZero: true
                        }
                    },
                    animation: {
                        duration: 0  // Disable animations
                    }
                }
            });
            
            // Load historical data for voltage/current chart
            loadDetailedHistoricalData(cage);
        }
        
        // Load historical data for detailed cage chart (voltage/current)
        function loadDetailedHistoricalData(cage) {
            if (!cageChart) {
                console.log('No cage chart to load data into');
                return;
            }
            
            console.log(`ðŸ”„ Loading detailed chart data for ${cage} (${currentTimeRange})`);
            
            const now = Date.now();
            const data = allCageData[cage];
            
            if (!data || data.length === 0) {
                console.log('No historical data available for detailed chart');
                return;
            }
            
            // Calculate target time range from current time backwards
            const timeRangeMs = getTimeRangeInMilliseconds(currentTimeRange);
            const targetEndTime = now;
            const targetStartTime = now - timeRangeMs;
            
            console.log(`ðŸ” ${cage}: Looking for CSV data from ${new Date(targetStartTime).toLocaleString()} to ${new Date(targetEndTime).toLocaleString()}`);
            
            // Find CSV data that falls within the target time range
            const csvTimeframeData = data.filter(record => 
                record.timestamp >= targetStartTime && record.timestamp <= targetEndTime
            );
            
            let timeframedData;
            if (csvTimeframeData.length > 0) {
                // Use actual CSV data with original timestamps
                timeframedData = csvTimeframeData;
                console.log(`âœ… ${cage}: Using ${csvTimeframeData.length} CSV records from ${new Date(csvTimeframeData[0].timestamp).toLocaleString()} to ${new Date(csvTimeframeData[csvTimeframeData.length - 1].timestamp).toLocaleString()}`);
            } else {
                // If no exact data, find the closest data point to current time
                const closest = data.reduce((prev, current) => {
                    return Math.abs(current.timestamp - now) < Math.abs(prev.timestamp - now) ? current : prev;
                });
                
                // Find the index of the closest point
                const closestIndex = data.findIndex(record => record.timestamp === closest.timestamp);
                
                // Get data points going backwards from the closest point
                const pointsNeeded = Math.min(50, data.length);
                const startIndex = Math.max(0, closestIndex - pointsNeeded + 1);
                timeframedData = data.slice(startIndex, closestIndex + 1);
                
                console.log(`âš ï¸ ${cage}: No data in exact timeframe, using ${timeframedData.length} records around ${new Date(closest.timestamp).toLocaleString()}`);
            }
            
            console.log(`ðŸ“Š Cage ${cage}: Loading ${timeframedData.length} records for detailed chart (${currentTimeRange})`);
            
            if (timeframedData.length > 0) {
                // Update chart time bounds to match the actual data range
                const dataStartTime = timeframedData[0].timestamp;
                const dataEndTime = timeframedData[timeframedData.length - 1].timestamp;
                
                const timeConfig = getTimeAxisConfig(currentTimeRange);
                cageChart.options.scales.x.time.unit = timeConfig.unit;
                cageChart.options.scales.x.time.displayFormats = {
                    [timeConfig.unit]: timeConfig.format
                };
                cageChart.options.scales.x.time.tooltipFormat = timeConfig.tooltipFormat;
                
                cageChart.options.scales.x.min = new Date(dataStartTime);
                cageChart.options.scales.x.max = new Date(dataEndTime);
                
                // Clear existing data
                cageChart.data.labels = [];
                cageChart.data.datasets[0].data = [];
                cageChart.data.datasets[1].data = [];
                
                // Load the historical data
                timeframedData.forEach(item => {
                    const time = new Date(item.timestamp);
                    cageChart.data.labels.push(time);
                    cageChart.data.datasets[0].data.push(item.voltage || 0);
                    cageChart.data.datasets[1].data.push(item.current || 0);
                });
                
                // Update point visibility based on current time range
                updateChartPointVisibility(cageChart, currentTimeRange);
                
                // Update without animation for initial load
                cageChart.update('none');
                
                console.log(`Detailed chart loaded with ${timeframedData.length} points for time range: ${currentTimeRange}`);
            }
            // After timeframedData is set, update the stats display with the last data point
            if (timeframedData && timeframedData.length > 0) {
                updateCageStats(cage, timeframedData[timeframedData.length - 1]);
            }
        }
        
        // Load DO historical data for cage DO chart using the same logic as main chart
        function loadDOHistoricalData(cage) {
            if (!window.cageDOChart) {
                console.log('No cage DO chart to load data into');
                return;
            }
            
            console.log(`ðŸ”„ Loading DO chart data for ${cage} (${currentTimeRange})`);
            
            const now = Date.now();
            const data = allCageData[cage];
            
            if (!data || data.length === 0) {
                console.log('No DO data available for cage chart');
                return;
            }
            
            // Calculate target time range from current time backwards
            const timeRangeMs = getTimeRangeInMilliseconds(currentTimeRange);
            const targetEndTime = now;
            const targetStartTime = now - timeRangeMs;
            
            console.log(`ðŸ” ${cage}: Looking for DO data from ${new Date(targetStartTime).toLocaleString()} to ${new Date(targetEndTime).toLocaleString()}`);
            
            // Find CSV data that falls within the target time range and has DO values
            const csvTimeframeData = data.filter(record => 
                record.timestamp >= targetStartTime && 
                record.timestamp <= targetEndTime &&
                record.do !== undefined && 
                record.do !== null
            );
            
            let timeframedData;
            if (csvTimeframeData.length > 0) {
                // Use actual CSV data with original timestamps
                timeframedData = csvTimeframeData;
                console.log(`âœ… ${cage}: Using ${csvTimeframeData.length} CSV DO records from ${new Date(csvTimeframeData[0].timestamp).toLocaleString()} to ${new Date(csvTimeframeData[csvTimeframeData.length - 1].timestamp).toLocaleString()}`);
            } else {
                // If no exact data, find the closest data point to current time with DO values
                const doRecords = data.filter(record => record.do !== undefined && record.do !== null);
                if (doRecords.length > 0) {
                    const closest = doRecords.reduce((prev, current) => {
                        return Math.abs(current.timestamp - now) < Math.abs(prev.timestamp - now) ? current : prev;
                    });
                    
                    // Find the index of the closest point
                    const closestIndex = doRecords.findIndex(record => record.timestamp === closest.timestamp);
                    
                    // Get data points going backwards from the closest point
                    const pointsNeeded = Math.min(50, doRecords.length);
                    const startIndex = Math.max(0, closestIndex - pointsNeeded + 1);
                    timeframedData = doRecords.slice(startIndex, closestIndex + 1);
                    
                    console.log(`âš ï¸ ${cage}: No DO data in exact timeframe, using ${timeframedData.length} records around ${new Date(closest.timestamp).toLocaleString()}`);
                } else {
                    console.log(`âŒ ${cage}: No DO data available at all`);
                    return;
                }
            }
            
            if (timeframedData.length > 0) {
                // Update chart time bounds to match the actual data range
                const dataStartTime = timeframedData[0].timestamp;
                const dataEndTime = timeframedData[timeframedData.length - 1].timestamp;
                
                const timeConfig = getTimeAxisConfig(currentTimeRange);
                window.cageDOChart.options.scales.x.time.unit = timeConfig.unit;
                window.cageDOChart.options.scales.x.time.displayFormats = {
                    [timeConfig.unit]: timeConfig.format
                };
                window.cageDOChart.options.scales.x.time.tooltipFormat = timeConfig.tooltipFormat;
                
                window.cageDOChart.options.scales.x.min = new Date(dataStartTime);
                window.cageDOChart.options.scales.x.max = new Date(dataEndTime);
                
                // Clear existing data
                window.cageDOChart.data.labels = [];
                window.cageDOChart.data.datasets[0].data = [];
                
                // Load the historical data
                timeframedData.forEach(item => {
                    const time = new Date(item.timestamp);
                    window.cageDOChart.data.labels.push(time);
                    window.cageDOChart.data.datasets[0].data.push(item.do);
                });
                
                // Auto-adjust y-axis range if needed
                adjustDOYAxisRange(window.cageDOChart);
                
                // Update point visibility based on current time range
                updateChartPointVisibility(window.cageDOChart, currentTimeRange);
                
                // Update without animation for initial load
                window.cageDOChart.update('none');
                
                console.log(`DO chart loaded with ${timeframedData.length} points for time range: ${currentTimeRange}`);
            }
        }

        // Load recent data for detailed cage chart (voltage/current) - legacy function
        function loadRecentDetailedDataForCage(cage) {
            const now = Date.now();
            const thirtySecondsAgo = now - 30000;
            
            if (!cageChart) return;
            
            // Create history array if it doesn't exist
            if (!cageData[cage + '_history']) {
                cageData[cage + '_history'] = [];
            }
            
            // Load recent data
            const recentData = cageData[cage + '_history'].slice(-50); // Get last 50 points
            
            // Populate chart with recent data
            recentData.forEach(data => {
                const time = new Date(data.timestamp);
                cageChart.data.labels.push(time);
                cageChart.data.datasets[0].data.push(data.voltage || 0);
                cageChart.data.datasets[1].data.push(data.current || 0);
            });
            
            cageChart.update('none');
            console.log(`Loaded ${recentData.length} recent detailed data points for ${cage}`);
        }
        
        // Initialize individual cage DO chart using proven pattern
        function initializeCageDOChart(cage) {
            console.log(`Initializing DO chart for ${cage}`);
            const canvas = document.getElementById('cage-do-chart');
            if (!canvas) {
                console.error('Canvas element cage-do-chart not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart
            if (window.cageDOChart) {
                window.cageDOChart.destroy();
            }
            
            // Create chart using the proven pattern from the working example
            window.cageDOChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'DO',
                        data: [],
                        fill: false,
                        borderColor: '#28a745',
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: `${cage.charAt(0).toUpperCase() + cage.slice(1)} DO Level`
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { 
                                unit: 'hour',
                                tooltipFormat: 'dd MMM HH:mm:ss',
                                displayFormats: {
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm',
                                    hour: 'HH:mm',
                                    day: 'MMM DD'
                                }
                            },

                            title: { 
                                display: true, 
                                text: 'Time' 
                            }
                        },
                        y: {
                            min: 2.2,
                            max: 3.2,
                            title: { 
                                display: true, 
                                text: 'DO (mg/L)' 
                            }
                        }
                    },
                    interaction: { 
                        mode: 'index', 
                        intersect: false 
                    },
                    animation: {
                        duration: 0  // Disable animations
                    }
                }
            });
            
            console.log(`DO chart created for ${cage}`);
            
            // Load historical data
            loadCageHistoricalDO(cage);
        }
        
        // Load historical DO data for individual cage
        function loadCageHistoricalDO(cage) {
            if (!window.cageDOChart) {
                console.log('No DO chart to load data into');
                return;
            }
            
            // Use the proper data source like other functions
            const data = allCageData[cage] || [];
            console.log(`Loading historical data for ${cage}:`, data.length, 'records');
            
            if (data.length === 0) {
                console.log('No historical data available');
                return;
            }
            
            // Use historical data ending at July 10, 2025
            const july10 = new Date('2025-07-10T00:00:00').getTime();
            const historicalData = data.filter(record => record.timestamp <= july10);
            const filteredData = filterDataByTimeRange(historicalData, currentTimeRange, july10);
            const processedData = ensureDataSpansTimeRange(filteredData, currentTimeRange, cage);
            
            // Get data with valid DO values
            const validDOData = processedData
                .filter(record => record.do !== undefined && record.do !== null && !isNaN(record.do));
            
            console.log(`Loaded ${validDOData.length} records with valid DO for ${cage}`);
            
            if (validDOData.length > 0) {
                // Update chart time bounds
                updateChartTimeBounds(window.cageDOChart, currentTimeRange);
                
                // Load the data
                window.cageDOChart.data.labels = validDOData.map(d => new Date(d.timestamp));
                window.cageDOChart.data.datasets[0].data = validDOData.map(d => d.do);
                
                // Update point visibility based on current time range
                updateChartPointVisibility(window.cageDOChart, currentTimeRange);
                
                // Update without animation for initial load
                window.cageDOChart.update('none');
                
                console.log(`DO chart loaded with ${validDOData.length} points for time range: ${currentTimeRange}`);
            }
        }
        
        // Update detailed view
        function updateDetailedView(cage, data) {
            document.getElementById('detail-voltage').textContent = data.voltage.toFixed(1);
            document.getElementById('detail-current').textContent = data.current.toFixed(2);
            document.getElementById('detail-battery').textContent = data.battery.toFixed(2);
            
            if (data.do !== undefined) {
                document.getElementById('detail-do').textContent = data.do.toFixed(1);
            }
            
            const time = luxon.DateTime.fromMillis(data.timestamp);
            document.getElementById('detail-timestamp').textContent = time.toFormat('HH:mm:ss');
        }
        
        // Filter data by time range
        function filterDataByTime(minutes) {
            const now = Date.now();
            const cutoff = now - (minutes * 60 * 1000);
            
            // Filter historical data for all charts
            Object.keys(charts).forEach(cage => {
                const chart = charts[cage];
                const filtered = historicalData[cage].filter(item => item.timestamp >= cutoff);
                
                chart.data.labels = filtered.map(item => new Date(item.timestamp));
                chart.data.datasets[0].data = filtered.map(item => item.voltage);
                chart.data.datasets[1].data = filtered.map(item => item.current);
                
                if (cage !== 'cage4') {
                    chart.data.datasets[2].data = filtered.map(item => item.do);
                }
                
                chart.update();
            });
        }
        
        // Download CSV function
        function downloadCSV(cage) {
            window.location.href = `/download/${cage}`;
        }
        
        // Update aerator status in navigation
        function updateAeratorStatus(cage, aeratorStatus) {
            if (cage === 'cage4') return; // Main system doesn't have aerator
            
            const statusIndicator = document.getElementById(`status-${cage}`);
            
            if (statusIndicator) {
                statusIndicator.className = 'status-indicator';
                
                if (aeratorStatus === 'on') {
                    statusIndicator.classList.add('aerator-on');
                    statusIndicator.title = 'Aerator ON - Oxygenating water';
                } else {
                    statusIndicator.classList.add('aerator-off');
                    statusIndicator.title = 'Aerator OFF - DO levels stable';
                }
            }
        }
        
        // Update aerator status in detailed view
        function updateDetailedAeratorStatus(cage, aeratorStatus) {
            const statusText = document.getElementById('aerator-status-text');
            const statusIcon = document.getElementById('aerator-status-icon');
            
            if (statusText && statusIcon) {
                if (aeratorStatus === 'on') {
                    statusText.textContent = 'ON';
                    statusText.style.color = '#3498db';
                    statusIcon.className = 'aerator-indicator aerator-on';
                } else {
                    statusText.textContent = 'OFF';
                    statusText.style.color = '#95a5a6';
                    statusIcon.className = 'aerator-indicator aerator-off';
                }
            }
        }
        
        // Time range management
        let currentTimeRange = 'realtime';
        
        // Function to get point radius based on time range
        function getPointRadius(timeRange) {
            const pointSettings = {
                'realtime': 4,  // Show points for real-time
                '1h': 3,        // Show points for 1 hour
                '3h': 2,        // Small points for 3 hours
                '6h': 1,        // Very small points for 6 hours
                '12h': 0,       // No points for 12 hours and beyond
                '1d': 0,
                '2d': 0,
                '3d': 0,
                '1w': 0,
                '2w': 0,
                '3w': 0,
                '1m': 0
            };
            
            return pointSettings[timeRange] || 0;
        }
        
        // Function to update chart point visibility
        function updateChartPointVisibility(chart, timeRange) {
            if (!chart) return;
            
            const pointRadius = getPointRadius(timeRange);
            const pointHoverRadius = pointRadius > 0 ? pointRadius + 2 : 3;
            
            chart.data.datasets.forEach(dataset => {
                dataset.pointRadius = pointRadius;
                dataset.pointHoverRadius = pointHoverRadius;
            });
            
            chart.update();
        }
        
        // Function to auto-adjust DO y-axis range if data goes outside 2.2-3.2
        function adjustDOYAxisRange(chart) {
            if (!chart || !chart.data.datasets) return;
            
            let minValue = 2.2; // Default min
            let maxValue = 3.2; // Default max
            
            // Check all DO values in all datasets
            chart.data.datasets.forEach(dataset => {
                if (dataset.data && dataset.data.length > 0) {
                    dataset.data.forEach(point => {
                        const value = typeof point === 'object' ? point.y : point;
                        if (value !== null && value !== undefined && !isNaN(value)) {
                            if (value < minValue) minValue = value - 0.1;
                            if (value > maxValue) maxValue = value + 0.1;
                        }
                    });
                }
            });
            
            // Update y-axis range if needed
            if (chart.options.scales.y.min !== minValue || chart.options.scales.y.max !== maxValue) {
                chart.options.scales.y.min = minValue;
                chart.options.scales.y.max = maxValue;
                console.log(`Adjusted DO y-axis range to ${minValue.toFixed(1)} - ${maxValue.toFixed(1)}`);
            }
        }

        // Update chart time bounds based on current time range
        function updateChartTimeBounds(chart, timeRange) {
            if (!chart || !chart.options.scales || !chart.options.scales.x) return;
            
            // Always use current time as reference for ALL modes
            const now = Date.now();
            const timeRangeMs = getTimeRangeInMilliseconds(timeRange);
            const minTime = new Date(now - timeRangeMs);
            const maxTime = new Date(now);
            
            chart.options.scales.x.min = minTime;
            chart.options.scales.x.max = maxTime;
            
            console.log(`Updated chart time bounds: ${minTime.toLocaleString()} to ${maxTime.toLocaleString()}`);
        }
        
        function updateCageTimeRange(timeRange) {
            currentTimeRange = timeRange;
            const cage = currentView;
            
            if (cage && cage !== 'dashboard') {
                console.log(`ðŸ”„ Switching cage ${cage} to timeframe: ${timeRange}`);
                
                // Repopulate data for the new timeframe
                populateChartsWithInitialData();
                
                // Refresh the cage charts
                loadAndRefreshCageData(cage);
            }
        }
        
        function updateDashboardTimeRange(timeRange) {
            currentTimeRange = timeRange;
            
            if (currentView === 'dashboard') {
                console.log(`ðŸ”„ Switching to timeframe: ${timeRange}`);
                
                // Repopulate data for the new timeframe
                populateChartsWithInitialData();
                
                // Refresh the dashboard chart
                refreshDashboardChart();
            }
        }
        
        function getTimeRangeInMilliseconds(timeRange) {
            const ranges = {
                'realtime': 3 * 60 * 1000,                 // 3 minutes
                '1h': 60 * 60 * 1000,                      // 1 hour
                '3h': 3 * 60 * 60 * 1000,                  // 3 hours
                '6h': 6 * 60 * 60 * 1000,                  // 6 hours
                '12h': 12 * 60 * 60 * 1000,                // 12 hours
                '1d': 24 * 60 * 60 * 1000,                 // 1 day
                '2d': 2 * 24 * 60 * 60 * 1000,             // 2 days
                '3d': 3 * 24 * 60 * 60 * 1000,             // 3 days
                '1w': 7 * 24 * 60 * 60 * 1000,             // 1 week
                '2w': 14 * 24 * 60 * 60 * 1000,            // 2 weeks
                '3w': 21 * 24 * 60 * 60 * 1000,            // 3 weeks
                '1m': 30 * 24 * 60 * 60 * 1000             // 1 month (30 days)
            };
            
            return ranges[timeRange] || ranges['realtime'];
        }
        
        function filterDataByTimeRange(data, timeRange, endTime = null) {
            if (!data || !Array.isArray(data)) return [];
            
            const referenceTime = endTime || Date.now(); // Use July 10 as reference for historical data
            const cutoffTime = referenceTime - getTimeRangeInMilliseconds(timeRange);
            
            console.log(`Filtering for time range: ${timeRange}, Cutoff time: ${new Date(cutoffTime).toLocaleString()}`);
            
            const filtered = data.filter(item => {
                const timestamp = typeof item.timestamp === 'string' ? 
                    new Date(item.timestamp).getTime() : 
                    item.timestamp;
                return timestamp >= cutoffTime && timestamp <= referenceTime;
            });
            
            console.log(`Original: ${data.length} records, Filtered: ${filtered.length} records`);
            return filtered;
        }
        
        // Get historical data for current timeframe (based on current time)
        function getHistoricalDataForCurrentTime(cage, timeRange) {
            const data = allCageData[cage] || [];
            if (data.length === 0) {
                console.warn(`âš ï¸ No data available for ${cage}`);
                return [];
            }
            
            const now = Date.now();
            const timeRangeMs = getTimeRangeInMilliseconds(timeRange);
            const startTime = now - timeRangeMs;
            
            console.log(`ðŸ” Looking for data between ${new Date(startTime).toLocaleString()} and ${new Date(now).toLocaleString()}`);
            
            // Find all data points within the time range
            const historicalData = data.filter(record => 
                record.timestamp >= startTime && record.timestamp <= now
            );
            
            console.log(`ðŸ•’ Historical data for ${cage} (${timeRange}): ${historicalData.length} points from ${new Date(startTime).toLocaleString()} to ${new Date(now).toLocaleString()}`);
            
            // If no data in current time range, let's see what data we do have
            if (historicalData.length === 0) {
                const firstRecord = data[0];
                const lastRecord = data[data.length - 1];
                console.log(`âš ï¸ No data in current time range for ${cage}. Available data spans: ${new Date(firstRecord.timestamp).toLocaleString()} to ${new Date(lastRecord.timestamp).toLocaleString()}`);
                
                // For demo purposes, return the last 100 records if no current data
                console.log(`ðŸ“‹ Using last 100 records for demo purposes`);
                return data.slice(-100);
            }
            
            return historicalData;
        }
        
        // Function to ensure data spans the full time range by interpolating/padding
        function ensureDataSpansTimeRange(data, timeRange, cage = null, endTime = null) {
            const rangeMs = getTimeRangeInMilliseconds(timeRange);
            const actualEndTime = endTime || Date.now();
            const startTime = actualEndTime - rangeMs;
            
            // Sort data by timestamp
            const sortedData = data ? [...data].sort((a, b) => a.timestamp - b.timestamp) : [];
            
            // Get the most recent values from cache if available
            const getDefaultValues = () => {
                if (cage && cageData[cage]) {
                    return {
                        do: cageData[cage].do || 3.0,
                        voltage: cageData[cage].voltage || 12.0,
                        current: cageData[cage].current || 1.5,
                        battery: cageData[cage].battery || 95.0
                    };
                }
                return {
                    do: 3.0,
                    voltage: 12.0,
                    current: 1.5,
                    battery: 95.0
                };
            };
            
            // If we have no data in the time range, create interpolated points spanning the entire range
            if (sortedData.length === 0) {
                console.log('No data available, creating interpolated points spanning full range');
                const defaultValues = getDefaultValues();
                
                // Create evenly spaced points across the entire time range, including exact start and end
                // Adjust density based on time range to avoid too many points for long periods
                let pointCount;
                if (rangeMs <= 24 * 60 * 60 * 1000) { // 1 day or less
                    pointCount = Math.max(5, Math.min(20, Math.floor(rangeMs / (30 * 60 * 1000)))); // 1 point per 30 minutes
                } else if (rangeMs <= 7 * 24 * 60 * 60 * 1000) { // 1 week or less
                    pointCount = Math.max(10, Math.min(30, Math.floor(rangeMs / (2 * 60 * 60 * 1000)))); // 1 point per 2 hours
                } else { // More than 1 week
                    pointCount = Math.max(15, Math.min(50, Math.floor(rangeMs / (6 * 60 * 60 * 1000)))); // 1 point per 6 hours
                }
                const interval = rangeMs / (pointCount - 1);
                
                const interpolatedData = [];
                for (let i = 0; i < pointCount; i++) {
                    // Add small random variations to make the line look more realistic
                    const variation = 1 + (Math.random() - 0.5) * 0.1; // Â±5% variation
                    const timestamp = i === 0 ? startTime : 
                                    i === pointCount - 1 ? actualEndTime : 
                                    startTime + (i * interval);
                    
                    interpolatedData.push({
                        timestamp: timestamp,
                        do: defaultValues.do * variation,
                        voltage: defaultValues.voltage * variation,
                        current: defaultValues.current * variation,
                        battery: Math.max(85, defaultValues.battery * variation)
                    });
                }
                console.log(`Created ${interpolatedData.length} interpolated points spanning full range`);
                return interpolatedData;
            }
            
            const result = [...sortedData];
            
            // ALWAYS ensure we have a point at the very start of the time range
            const firstDataTime = sortedData[0].timestamp;
            const timeGapAtStart = firstDataTime - startTime;
            if (timeGapAtStart > 0) { // If there's ANY gap at start
                // Add a point exactly at the start time
                const startPoint = {
                    ...sortedData[0], // Use first data point's values
                    timestamp: startTime
                };
                result.unshift(startPoint);
                console.log(`Added starting point at exact time range beginning (gap: ${Math.round(timeGapAtStart / 60000)} minutes)`);
                
                // Add intermediate points if the gap is large
                if (timeGapAtStart > rangeMs * 0.1) { // If gap is more than 10% of range
                    const midPoint = {
                        ...sortedData[0],
                        timestamp: startTime + (timeGapAtStart / 2)
                    };
                    result.splice(1, 0, midPoint); // Insert after start point but before existing data
                    console.log(`Added intermediate starting point for large gap`);
                }
            }
            
            // ALWAYS ensure we have a point at the very end of the time range
            const lastDataTime = sortedData[sortedData.length - 1].timestamp;
            const timeGapAtEnd = actualEndTime - lastDataTime;
            if (timeGapAtEnd > 0) { // If there's ANY gap at end
                // Add intermediate points if the gap is large
                if (timeGapAtEnd > rangeMs * 0.1) { // If gap is more than 10% of range
                    const midPoint = {
                        ...sortedData[sortedData.length - 1],
                        timestamp: lastDataTime + (timeGapAtEnd / 2)
                    };
                    result.push(midPoint);
                    console.log(`Added intermediate ending point for large gap`);
                }
                
                // Add a point exactly at the end time
                const endPoint = {
                    ...sortedData[sortedData.length - 1], // Use last data point's values
                    timestamp: actualEndTime
                };
                result.push(endPoint);
                console.log(`Added ending point at exact time range end (gap: ${Math.round(timeGapAtEnd / 60000)} minutes)`);
            }
            
            console.log(`Data enhanced: ${sortedData.length} â†’ ${result.length} points spanning ${new Date(result[0].timestamp).toLocaleString()} to ${new Date(result[result.length - 1].timestamp).toLocaleString()}`);
            return result;
        }
        
        function getTimeAxisConfig(timeRange) {
            const configs = {
                'realtime': { 
                    unit: 'second', 
                    format: 'HH:mm:ss', 
                    stepSize: 30,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '1h': { 
                    unit: 'minute', 
                    format: 'HH:mm', 
                    stepSize: 5,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '3h': { 
                    unit: 'minute', 
                    format: 'HH:mm', 
                    stepSize: 15,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '6h': { 
                    unit: 'hour', 
                    format: 'HH:mm', 
                    stepSize: 1,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '12h': { 
                    unit: 'hour', 
                    format: 'HH:mm', 
                    stepSize: 2,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '1d': { 
                    unit: 'hour', 
                    format: 'HH:mm', 
                    stepSize: 3,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '2d': { 
                    unit: 'hour', 
                    format: 'MMM DD HH:mm', 
                    stepSize: 6,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '3d': { 
                    unit: 'day', 
                    format: 'MMM DD', 
                    stepSize: 1,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '1w': { 
                    unit: 'day', 
                    format: 'MMM DD', 
                    stepSize: 1,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '2w': { 
                    unit: 'day', 
                    format: 'MMM DD', 
                    stepSize: 2,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '3w': { 
                    unit: 'day', 
                    format: 'MMM DD', 
                    stepSize: 3,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                },
                '1m': { 
                    unit: 'week', 
                    format: 'MMM DD', 
                    stepSize: 1,
                    tooltipFormat: 'dd MMM HH:mm:ss'
                }
            };
            
            return configs[timeRange] || configs['realtime'];
        }

        // Mobile menu functions
        function toggleMobileMenu() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.querySelector('.mobile-overlay');
            
            sidebar.classList.toggle('mobile-open');
            overlay.classList.toggle('active');
        }
        
        function closeMobileMenu() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.querySelector('.mobile-overlay');
            
            sidebar.classList.remove('mobile-open');
            overlay.classList.remove('active');
        }
        
        // Close mobile menu when navigation item is clicked
        function switchView(view) {
            currentView = view;
            const dashboardView = document.getElementById('dashboard-view');
            const cageView = document.getElementById('cage-view');
            const importantDatesView = document.getElementById('important-dates-view');
            const pageTitle = document.getElementById('page-title');
            
            // Update navigation highlighting
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                item.classList.remove('active');
                if (item.dataset.view === view) {
                    item.classList.add('active');
                }
            });
            
            if (view === 'dashboard') {
                dashboardView.style.display = 'block';
                cageView.style.display = 'none';
                importantDatesView.style.display = 'none';
                pageTitle.textContent = 'Dashboard Overview';
                const dashboardTimeRange = document.getElementById('dashboard-time-range');
                if (dashboardTimeRange) {
                    dashboardTimeRange.value = currentTimeRange;
                }
                setTimeout(() => refreshDashboardChart(), 100);
            } else if (view === 'important-dates') {
                dashboardView.style.display = 'none';
                cageView.style.display = 'none';
                importantDatesView.style.display = 'block';
                pageTitle.textContent = 'Important Dates';
                updateImportantDatesView();
            } else {
                // Any cage view (cage1, cage2, cage3, cage4)
                dashboardView.style.display = 'none';
                cageView.style.display = 'block';
                importantDatesView.style.display = 'none';
                pageTitle.textContent =
                    view === 'cage4' ? 'Main System Details' : `${view.charAt(0).toUpperCase() + view.slice(1)} Details`;
                const cageTimeRange = document.getElementById('cage-time-range');
                if (cageTimeRange) {
                    cageTimeRange.value = currentTimeRange;
                }
                showCageDetails(view);
                if (Object.keys(allCageData).length > 0) {
                    setTimeout(() => {
                        loadAndRefreshCageData(view);
                    }, 150);
                } else {
                    console.log('âš ï¸ Cage data not loaded yet for view switching');
                }
            }
            closeMobileMenu();
        }
        
        // Test DO chart function
        function testDOChart() {
            if (!window.cageDOChart) {
                alert('No DO chart found! Make sure you are viewing a cage with DO sensor (Cage 1, 2, or 3)');
                return;
            }
            
            // Add a test data point
            const testData = {
                timestamp: Date.now(),
                do: Math.random() * 3 + 2 // Random value between 2-5
            };
            
            updateCageDOChart(currentView, testData);
            console.log('Test data point added to DO chart');
        }
        
        // Debug function to check time range status
        window.debugTimeRange = function() {
            console.log('=== TIME RANGE DEBUG ===');
            console.log('Current view:', currentView);
            console.log('Current time range:', currentTimeRange);
            console.log('Time range in milliseconds:', getTimeRangeInMilliseconds(currentTimeRange));
            const now = Date.now();
            const cutoff = now - getTimeRangeInMilliseconds(currentTimeRange);
            // console.log('Now:', new Date(now).toLocaleString());
            // console.log('Cutoff time:', new Date(cutoff).toLocaleString());

            console.log('Now:', new Date(now).toLocaleDateString());
            console.log('Cutoff time:', new Date(cutoff).toLocaleDateString());
            
            if (window.cageDOChart) {
                console.log('DO Chart data points:', window.cageDOChart.data.labels.length);
                console.log('Chart min time:', window.cageDOChart.options.scales.x.min);
                console.log('Chart max time:', window.cageDOChart.options.scales.x.max);
            }
            
            if (cageChart) {
                console.log('Voltage/Current Chart data points:', cageChart.data.labels.length);
            }
        }
        
        // Password change functionality removed
        
        // Download current time range data
        function downloadCurrentTimeRange(source = null) {
            // Use the current view (cage) for download, not dashboard
            const cage = currentView;
            
            // Don't allow download from dashboard
            if (cage === 'dashboard') {
                alert('Download is not available for Dashboard view. Please select a specific cage.');
                return;
            }
            
            try {
                const data = allCageData[cage] || [];
                
                if (data.length === 0) {
                    alert('No data available for download.');
                    return;
                }
                
                // Use current system time and subtract 10 hours for timezone conversion
                const currentTime = Date.now();
                // const timezoneOffset = 0; // 10 hours in milliseconds
                const timezoneOffset = 4 * 60 * 60 * 1000;
                const adjustedCurrentTime = currentTime - timezoneOffset;
                const timeRangeMs = getTimeRangeInMilliseconds(currentTimeRange);
                const startTime = adjustedCurrentTime - timeRangeMs;
                
                console.log(`ðŸ• Current time (local): ${new Date(currentTime).toLocaleString()}`);
                console.log(`ðŸ• Adjusted time (UTC): ${new Date(adjustedCurrentTime).toLocaleString()}`);
                console.log(`ðŸ“Š Timeframe: ${currentTimeRange} (${timeRangeMs / (1000 * 60)} minutes)`);
                console.log(`ðŸ• Download time range: ${new Date(startTime).toLocaleString()} to ${new Date(adjustedCurrentTime).toLocaleString()}`);
                
                // Filter data for the adjusted time range
                const filteredData = data.filter(record => 
                    record.timestamp >= startTime && record.timestamp <= adjustedCurrentTime
                );
                
                console.log(`ðŸ“„ Found ${filteredData.length} records in time range out of ${data.length} total records`);
                
                if (filteredData.length === 0) {
                    alert('No data found for the selected time range.');
                    return;
                }
                
                // Generate CSV content
                const hasDO = cage !== 'cage4';
                let csvContent = hasDO ? 
                    'Timestamp,DO,Voltage,Current,Battery\n' : 
                    'Timestamp,Voltage,Current,Battery\n';
                
                filteredData.forEach(record => {
                    const timestamp = new Date(record.timestamp).toISOString().replace('T', ' ').slice(0, 19);
                    if (hasDO) {
                        csvContent += `${timestamp},${record.do},${record.voltage},${record.current},${record.battery}\n`;
                    } else {
                        csvContent += `${timestamp},${record.voltage},${record.current},${record.battery}\n`;
                    }
                });
                
                // Create and download file
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                
                const timeRangeLabel = currentTimeRange === 'realtime' ? 'realtime_3min' : currentTimeRange;
                const downloadTime = new Date().toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-');
                a.download = `${cage}_${timeRangeLabel}_${downloadTime}.csv`;
                
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                console.log(`âœ… Downloaded ${filteredData.length} records for ${cage} (${currentTimeRange})`);
                console.log(`ðŸ“ File: ${a.download}`);
                
            } catch (error) {
                console.error('Download error:', error);
                alert('Error generating download file.');
            }
        }
        
        // Download Modal Functions
        function openDownloadModal() {
            const modal = document.getElementById('downloadModal');
            const currentCage = currentView === 'dashboard' ? 'cage1' : currentView;
            document.getElementById('cage-select').value = currentCage;
            modal.style.display = 'block';
        }
        
        function closeDownloadModal() {
            const modal = document.getElementById('downloadModal');
            modal.style.display = 'none';
            const message = document.getElementById('download-message');
            message.style.display = 'none';
        }
        
        // Update download date inputs based on timeframe selection
        function updateDownloadDates(timeframe) {
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            
            if (timeframe === 'custom') {
                // Enable custom date inputs
                startDateInput.disabled = false;
                endDateInput.disabled = false;
                return;
            }
            
            // Calculate dates based on timeframe
            const now = new Date();
            const timeRangeMs = getTimeRangeInMilliseconds(timeframe);
            const startDate = new Date(now.getTime() - timeRangeMs);
            
            // Format dates for datetime-local input
            const formatDateTime = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${year}-${month}-${day}T${hours}:${minutes}`;
            };
            
            startDateInput.value = formatDateTime(startDate);
            endDateInput.value = formatDateTime(now);
            
            // Disable inputs for preset timeframes
            startDateInput.disabled = true;
            endDateInput.disabled = true;
        }
        
        function downloadDateRange() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const cage = document.getElementById('cage-select').value;
            const message = document.getElementById('download-message');
            
            if (!startDate || !endDate) {
                message.textContent = 'Please select both start and end dates.';
                message.className = 'message error';
                message.style.display = 'block';
                return;
            }
            
            const startTime = new Date(startDate).getTime();
            const endTime = new Date(endDate).getTime();
            
            if (startTime >= endTime) {
                message.textContent = 'End date must be after start date.';
                message.className = 'message error';
                message.style.display = 'block';
                return;
            }
            
            try {
                const data = allCageData[cage] || [];
                const filteredData = data.filter(record => 
                    record.timestamp >= startTime && record.timestamp <= endTime
                );
                
                if (filteredData.length === 0) {
                    message.textContent = 'No data found in the selected date range.';
                    message.className = 'message error';
                    message.style.display = 'block';
                    return;
                }
                
                // Generate CSV content
                const hasDO = cage !== 'cage4';
                let csvContent = hasDO ? 
                    'Timestamp,DO,Voltage,Current,Battery\n' : 
                    'Timestamp,Voltage,Current,Battery\n';
                
                filteredData.forEach(record => {
                    const timestamp = new Date(record.timestamp).toISOString().replace('T', ' ').slice(0, 19);
                    if (hasDO) {
                        csvContent += `${timestamp},${record.do},${record.voltage},${record.current},${record.battery}\n`;
                    } else {
                        csvContent += `${timestamp},${record.voltage},${record.current},${record.battery}\n`;
                    }
                });
                
                // Create and download file
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                
                const startStr = new Date(startTime).toISOString().slice(0, 10);
                const endStr = new Date(endTime).toISOString().slice(0, 10);
                a.download = `${cage}_${startStr}_to_${endStr}.csv`;
                
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                message.textContent = `âœ… Downloaded ${filteredData.length} records successfully!`;
                message.className = 'message success';
                message.style.display = 'block';
                
                setTimeout(() => {
                    closeDownloadModal();
                }, 2000);
                
            } catch (error) {
                console.error('Download error:', error);
                message.textContent = 'Error generating download file.';
                message.className = 'message error';
                message.style.display = 'block';
            }
        }

        // Utility: Get the latest timestamp from all loaded data
        function getLatestDataTimestamp() {
            let latest = 0;
            Object.values(allCageData).forEach(dataArr => {
                if (Array.isArray(dataArr) && dataArr.length > 0) {
                    const last = dataArr[dataArr.length - 1].timestamp;
                    if (last > latest) latest = last;
                }
            });
            return latest > 0 ? latest : Date.now();
        }

        // Add this function to handle the new download button
        function downloadPastMonth(event) {
            let cage = null;
            if (event && event.target && event.target.getAttribute) {
                cage = event.target.getAttribute('data-cage');
            }
            if (!cage) {
                // fallback to currentView if not called from button
                cage = window.currentView;
            }
            if (!cage || !allCageData[cage]) {
                alert('No cage selected or data unavailable.');
                return;
            }
            const data = allCageData[cage];
            if (!data || data.length === 0) {
                alert('No data available for this cage.');
                return;
            }
            // Get the current date and time
            const now = new Date();
            // Calculate the date one month ago, at 00:00:00
            const oneMonthAgo = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate(), 0, 0, 0, 0);
            const startTime = oneMonthAgo.getTime();
            const endTime = now.getTime();
            // Filter data for the past month (from one month ago at 00:00:00 to now)
            const filteredData = data.filter(record => record.timestamp >= startTime && record.timestamp <= endTime);
            if (filteredData.length === 0) {
                alert('No data found for the past month.');
                return;
            }
            // Generate CSV content
            const hasDO = cage !== 'cage4';
            let csvContent = hasDO ? 'Timestamp,DO,Voltage,Current,Battery,Aerator\n' : 'Timestamp,Voltage,Current,Battery\n';
            filteredData.forEach(record => {
                const timestamp = new Date(record.timestamp).toISOString().replace('T', ' ').slice(0, 19);
                if (hasDO) {
                    csvContent += `${timestamp},${record.do},${record.voltage},${record.current},100%,${record.aerator || ''}\n`;
                } else {
                    csvContent += `${timestamp},${record.voltage},${record.current},100%\n`;
                }
            });
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `${cage}_past_month_${oneMonthAgo.toISOString().slice(0, 10)}_to_${now.toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // Add logic to update the Important Dates view
        function updateImportantDatesView() {
            const cage = document.getElementById('important-cage-select').value;
            const date = document.getElementById('important-date-select').value;
            const chartCanvas = document.getElementById('important-dates-do-chart');
            if (!chartCanvas) return;
            if (window.importantDatesDOChart) {
                window.importantDatesDOChart.destroy();
            }
            const data = allCageData[cage] || [];
            const start = new Date(date + 'T00:00:00').getTime();
            const end = new Date(date + 'T23:59:59').getTime();
            const dayData = data.filter(d => d.timestamp >= start && d.timestamp <= end && typeof d.do === 'number' && !isNaN(d.do));
            const labels = dayData.map(d => new Date(d.timestamp));
            const doValues = dayData.map(d => d.do);
            window.importantDatesDOChart = new Chart(chartCanvas.getContext('2d'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'DO (mg/L)',
                        data: doValues,
                        borderColor: '#27ae60',
                        backgroundColor: 'rgba(39, 174, 96, 0.1)',
                        tension: 0.4,
                        fill: false,
                        pointRadius: 2,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: `DO Level for ${cage.charAt(0).toUpperCase() + cage.slice(1)} on ${date}` }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'hour', displayFormats: { hour: 'HH:mm' } },
                            title: { display: true, text: 'Time' }
                        },
                        y: {
                            suggestedMin: 1.0,
                            title: { display: true, text: 'DO (mg/L)' }
                        }
                    }
                }
            });
        }

        // Update event listeners for selects to use new chart logic
        setTimeout(() => {
            const cageSelect = document.getElementById('important-cage-select');
            const dateSelect = document.getElementById('important-date-select');
            if (cageSelect) cageSelect.addEventListener('change', updateImportantDatesView);
            if (dateSelect) dateSelect.addEventListener('change', updateImportantDatesView);
            // Initial render
            updateImportantDatesView();
        }, 500);
    </script>

</body>
</html>
